name: Auto Release

on:
  pull_request:
    types: [closed]
    branches: [main, master]

# Ensure only one release workflow runs at a time to prevent conflicts
concurrency:
  group: auto-release-${{ github.ref }}
  cancel-in-progress: false  # Queue releases instead of cancelling

permissions:
  contents: read  # Default read-only

jobs:
  # Guard job to prevent workflow failure when triggered on wrong event type
  event-guard:
    name: Event Type Check
    runs-on: ubuntu-latest
    outputs:
      should-run: ${{ github.event_name == 'pull_request' && github.event.pull_request.merged == true }}
    steps:
      - name: Check event and PR status
        run: |
          echo "ðŸ” Event Analysis"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "Event type: ${{ github.event_name }}"
          echo "PR merged: ${{ github.event.pull_request.merged }}"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          
          if [ "${{ github.event_name }}" != "pull_request" ]; then
            echo ""
            echo "â„¹ï¸  This workflow is designed for pull_request events"
            echo "Current trigger: ${{ github.event_name }}"
            echo ""
            echo "ðŸ’¡ This is normal when workflow files are modified"
            echo "Skipping auto-release workflow execution"
            exit 0
          fi
          
          if [ "${{ github.event.pull_request.merged }}" != "true" ]; then
            echo ""
            echo "â„¹ï¸  Pull request was closed without merging"
            echo "Skipping auto-release workflow execution"
            exit 0
          fi
          
          echo ""
          echo "âœ… Pull request was merged - proceeding with auto-release"

  # Run comprehensive tests before releasing
  test:
    name: Pre-release Tests
    needs: event-guard
    if: needs.event-guard.outputs.should-run == 'true'
    permissions:
      contents: read
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false  # See all platform failures for better diagnostics
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        rust: [stable]
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: ${{ matrix.rust }}
          components: clippy, rustfmt

      - name: Cache cargo
        uses: Swatinem/rust-cache@v2
        with:
          shared-key: "test-${{ matrix.os }}-${{ matrix.rust }}"
          cache-on-failure: true

      - name: Check formatting
        run: cargo fmt --check

      - name: Run clippy
        run: cargo clippy -- -D warnings

      - name: Build
        run: cargo build --release

      - name: Run tests
        run: cargo test

  create-version-bump-pr:
    name: Create Version Bump PR
    needs: [event-guard, test]  # Explicit dependency for clear conditional checking
    if: needs.event-guard.outputs.should-run == 'true'
    permissions:
      contents: write  # Required for creating branches and PRs
      pull-requests: write  # Required for creating PRs
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }}
          fetch-depth: 0
          # Use PAT if available to enable auto-merge and workflow triggering
          # Falls back to GITHUB_TOKEN for basic operations
          token: ${{ secrets.RELEASE_PAT || secrets.GITHUB_TOKEN }}

      - name: Validate PR metadata
        id: validate
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          if [ -z "$PR_TITLE" ]; then
            echo "::error::PR title is empty. Cannot determine version bump."
            exit 1
          fi
          echo "PR title validated: $PR_TITLE"

      - name: Check if release needed
        id: check_release
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Skip if PR title contains [skip release] or [no release]
          if echo "$PR_TITLE" | grep -qiE "\[(skip|no).?release\]"; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Skipping release due to [skip release] in PR title"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Install Rust
        if: steps.check_release.outputs.skip == 'false'
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-edit
        if: steps.check_release.outputs.skip == 'false'
        uses: taiki-e/install-action@v2
        with:
          tool: cargo-edit@0.12.2

      - name: Determine version bump type
        if: steps.check_release.outputs.skip == 'false'
        id: bump_type
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_LABELS: ${{ toJSON(github.event.pull_request.labels.*.name) }}
        run: |
          set -e  # Exit on any error
          
          echo "ðŸ” Analyzing PR for version bump type"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "PR Title: $PR_TITLE"
          echo "PR Labels: $PR_LABELS"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo ""
          
          # Initialize bump type
          BUMP_TYPE="patch"
          REASON="default (no specific indicators found)"
          
          # Check for BREAKING CHANGE (highest priority)
          # Patterns:
          # - feat! or fix! (conventional commits with !)
          # - BREAKING CHANGE: in title
          # - [breaking] tag in title
          # - "breaking" or "breaking-change" label
          
          # Normalize title for case-insensitive matching (preserve original for display)
          TITLE_LOWER=$(echo "$PR_TITLE" | tr '[:upper:]' '[:lower:]')
          
          # Check for breaking change indicators in title
          # Regex explained: (^|[^a-z]) = start of string OR non-letter (word boundary)
          #                  (feat|fix|...) = conventional commit type
          #                  ! = breaking change marker
          #                  \s* = optional whitespace
          #                  (\(|:) = scope with parenthesis OR colon
          if echo "$TITLE_LOWER" | grep -qE '(^|[^a-z])(feat|fix|chore|docs|style|refactor|perf|test)!\s*(\(|:)'; then
            BUMP_TYPE="major"
            REASON="conventional commit with '!' (breaking change marker)"
            echo "âœ“ Detected: $REASON"
          elif echo "$TITLE_LOWER" | grep -qE '\bbreaking\s+change\b'; then
            BUMP_TYPE="major"
            REASON="'BREAKING CHANGE' found in title"
            echo "âœ“ Detected: $REASON"
          elif echo "$TITLE_LOWER" | grep -qE '\[breaking\]'; then
            BUMP_TYPE="major"
            REASON="[breaking] tag in title"
            echo "âœ“ Detected: $REASON"
          # Check labels for breaking change
          elif echo "$PR_LABELS" | grep -qiE '(breaking|breaking-change)'; then
            BUMP_TYPE="major"
            REASON="'breaking' or 'breaking-change' label"
            echo "âœ“ Detected: $REASON"
          
          # Check for FEATURE (minor version bump)
          # Patterns:
          # - feat: or feat( (conventional commits)
          # - [feat] tag
          # - "feature" or "enhancement" label
          # Regex explained: (^|[^a-z]) = start of string OR non-letter (ensures 'feat' is a word, not part of 'defeat')
          #                  feat = feature keyword
          #                  \s* = optional whitespace
          #                  (\(|:) = scope with parenthesis OR colon
          elif echo "$TITLE_LOWER" | grep -qE '(^|[^a-z])feat\s*(\(|:)'; then
            BUMP_TYPE="minor"
            REASON="conventional commit 'feat:' or 'feat(...)'"
            echo "âœ“ Detected: $REASON"
          elif echo "$TITLE_LOWER" | grep -qE '\[feat\]'; then
            BUMP_TYPE="minor"
            REASON="[feat] tag in title"
            echo "âœ“ Detected: $REASON"
          elif echo "$PR_LABELS" | grep -qiE '(feature|enhancement)'; then
            BUMP_TYPE="minor"
            REASON="'feature' or 'enhancement' label"
            echo "âœ“ Detected: $REASON"
          
          # Default to PATCH for everything else
          # This includes: fix:, docs:, chore:, style:, refactor:, perf:, test:, build:, ci:, etc.
          else
            echo "â„¹ï¸  No major or minor indicators found - defaulting to patch bump"
            echo "   This is appropriate for: bug fixes, docs, chores, style, refactors, etc."
          fi
          
          echo ""
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "ðŸ“Š Decision Summary"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo "Bump Type: $BUMP_TYPE"
          echo "Reason: $REASON"
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          
          # Validate bump type before outputting
          if ! echo "$BUMP_TYPE" | grep -qE '^(major|minor|patch)$'; then
            echo "::error::Invalid bump type determined: '$BUMP_TYPE'. Must be major, minor, or patch."
            exit 1
          fi
          
          # Output to GitHub Actions
          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "bump_reason=$REASON" >> $GITHUB_OUTPUT
          
          echo ""
          echo "âœ… Version bump type determined successfully"

      - name: Bump version in Cargo.toml
        if: steps.check_release.outputs.skip == 'false'
        id: version
        run: |
          set -e  # Exit on error
          
          OLD_VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name == "oops") | .version')
          echo "ðŸ“¦ Current version: $OLD_VERSION"
          
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          echo "â¬†ï¸  Bumping $BUMP_TYPE version..."
          
          if ! cargo set-version --bump "$BUMP_TYPE"; then
            echo "::error::Failed to bump version. Check cargo-edit installation."
            exit 1
          fi
          
          NEW_VERSION=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name == "oops") | .version')
          
          if [ "$OLD_VERSION" = "$NEW_VERSION" ]; then
            echo "::error::Version did not change. Old: $OLD_VERSION, New: $NEW_VERSION"
            exit 1
          fi
          
          echo "âœ… Version bumped: $OLD_VERSION â†’ $NEW_VERSION"
          echo "old_version=$OLD_VERSION" >> $GITHUB_OUTPUT
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update Cargo.lock
        if: steps.check_release.outputs.skip == 'false'
        run: |
          PACKAGE_NAME=$(cargo metadata --no-deps --format-version 1 | jq -r '.packages[] | select(.name == "oops") | .name')
          cargo update -p "$PACKAGE_NAME"

      - name: Validate version bump
        if: steps.check_release.outputs.skip == 'false'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          
          # Verify version format (semver)
          if ! echo "$NEW_VERSION" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+$'; then
            echo "::error::Invalid version format: $NEW_VERSION"
            exit 1
          fi
          
          # Verify Cargo.lock was updated
          if ! git diff Cargo.lock | grep -q "+version = \"$NEW_VERSION\""; then
            echo "::error::Cargo.lock was not properly updated"
            exit 1
          fi
          
          # Verify we're not creating a duplicate version
          if git tag -l | grep -q "^v$NEW_VERSION$"; then
            echo "::error::Version v$NEW_VERSION already exists as a tag"
            exit 1
          fi
          
          echo "âœ… Version bump validated successfully"

      - name: Check for existing version bump PR
        if: steps.check_release.outputs.skip == 'false'
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          BRANCH_NAME="release/v$NEW_VERSION"
          
          # Check if branch exists remotely
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âš ï¸  Branch $BRANCH_NAME already exists remotely"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Create version bump branch and commit
        if: steps.check_release.outputs.skip == 'false' && steps.check_pr.outputs.exists == 'false'
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          BRANCH_NAME="release/v$NEW_VERSION"
          
          # Configure git for bot
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # Create new branch from current master
          git checkout -b "$BRANCH_NAME"
          
          # Stage version changes
          git add Cargo.toml Cargo.lock
          
          # Create commit
          git commit -m "chore: bump version to $NEW_VERSION" \
                     -m "" \
                     -m "Auto-generated version bump for release v$NEW_VERSION" \
                     -m "" \
                     -m "Type: ${{ steps.bump_type.outputs.bump_type }} bump" \
                     -m "Reason: ${{ steps.bump_type.outputs.bump_reason }}" \
                     -m "Source PR: #${{ github.event.pull_request.number }}" \
                     -m "Title: ${{ github.event.pull_request.title }}"
          
          # Push branch
          git push origin "$BRANCH_NAME"
          
          echo "âœ… Created and pushed branch: $BRANCH_NAME"

      - name: Create Pull Request for version bump
        if: steps.check_release.outputs.skip == 'false' && steps.check_pr.outputs.exists == 'false'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          OLD_VERSION="${{ steps.version.outputs.old_version }}"
          BUMP_TYPE="${{ steps.bump_type.outputs.bump_type }}"
          BUMP_REASON="${{ steps.bump_type.outputs.bump_reason }}"
          BRANCH_NAME="release/v$NEW_VERSION"
          BASE_BRANCH="${{ github.event.pull_request.base.ref }}"
          PR_NUMBER="${{ github.event.pull_request.number }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          
          # Create PR body
          cat > pr_body.md << 'EOFBODY'
          ## ðŸš€ Automated Version Bump
          
          This PR bumps the version for the next release.
          
          ### Version Information
          - **Old Version**: OLD_VERSION_PLACEHOLDER
          - **New Version**: NEW_VERSION_PLACEHOLDER
          - **Bump Type**: BUMP_TYPE_PLACEHOLDER
          - **Reason**: BUMP_REASON_PLACEHOLDER
          
          ### Source
          - **Trigger PR**: #PR_NUMBER_PLACEHOLDER
          - **PR Title**: `PR_TITLE_PLACEHOLDER`
          
          ### What's Changed
          - Updated `Cargo.toml` version
          - Updated `Cargo.lock`
          
          ### Next Steps
          1. âœ… **Auto-merge enabled** - This PR will merge automatically after checks pass
          2. ðŸ·ï¸ **Tag created** - Release tag `vNEW_VERSION_PLACEHOLDER` will be created on merge
          3. ðŸ“¦ **Release workflow** - Binaries will be built automatically
          
          ---
          
          ðŸ¤– *This PR was automatically created by the [auto-release workflow](.github/workflows/auto-release.yml)*
          EOFBODY
          
          # Replace placeholders
          sed -i "s/OLD_VERSION_PLACEHOLDER/$OLD_VERSION/g" pr_body.md
          sed -i "s/NEW_VERSION_PLACEHOLDER/$NEW_VERSION/g" pr_body.md
          sed -i "s/BUMP_TYPE_PLACEHOLDER/$BUMP_TYPE/g" pr_body.md
          sed -i "s#BUMP_REASON_PLACEHOLDER#$BUMP_REASON#g" pr_body.md
          sed -i "s/PR_NUMBER_PLACEHOLDER/$PR_NUMBER/g" pr_body.md
          sed -i "s#PR_TITLE_PLACEHOLDER#$PR_TITLE#g" pr_body.md
          
          # Create PR
          PR_URL=$(gh pr create \
            --base "$BASE_BRANCH" \
            --head "$BRANCH_NAME" \
            --title "chore: release v$NEW_VERSION" \
            --body-file pr_body.md \
            --label "release" \
            --label "automated")
          
          echo "pr_url=$PR_URL" >> $GITHUB_OUTPUT
          echo "âœ… Created PR: $PR_URL"

      - name: Enable auto-merge for version bump PR
        if: steps.check_release.outputs.skip == 'false' && steps.check_pr.outputs.exists == 'false' && secrets.RELEASE_PAT != ''
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PAT }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          BRANCH_NAME="release/v$NEW_VERSION"
          
          # Wait a moment for PR to be fully created
          sleep 2
          
          # Get PR number
          PR_NUMBER=$(gh pr list --head "$BRANCH_NAME" --json number --jq '.[0].number')
          
          if [ -z "$PR_NUMBER" ]; then
            echo "::warning::Could not find PR number. Auto-merge will not be enabled."
            echo "You'll need to merge the PR manually."
            exit 0
          fi
          
          # Enable auto-merge with squash strategy
          gh pr merge "$PR_NUMBER" --auto --squash
          
          echo "âœ… Enabled auto-merge for PR #$PR_NUMBER"
          echo "â„¹ï¸  PR will merge automatically once checks pass"

      - name: Create workflow summary
        if: steps.check_release.outputs.skip == 'false' && steps.check_pr.outputs.exists == 'false'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          NEW_VERSION="${{ steps.version.outputs.new_version }}"
          OLD_VERSION="${{ steps.version.outputs.old_version }}"
          PR_URL="${{ steps.create_pr.outputs.pr_url }}"
          HAS_PAT="${{ secrets.RELEASE_PAT != '' }}"
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## ðŸš€ Version Bump PR Created
          
          ### Version Information
          - **Old Version**: $OLD_VERSION
          - **New Version**: v$NEW_VERSION
          - **Bump Type**: ${{ steps.bump_type.outputs.bump_type }}
          - **Reason**: ${{ steps.bump_type.outputs.bump_reason }}
          - **Source PR**: #${{ github.event.pull_request.number }} - ${PR_TITLE}
          
          ### ðŸ“ Version Bump PR
          Created: [$PR_URL]($PR_URL)
          
          EOF
          
          if [ "$HAS_PAT" = "true" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          âœ… **Auto-merge enabled** - PR will merge automatically when checks pass
          
          ### What happens next?
          1. â³ CI checks run on the version bump PR
          2. âœ… Once checks pass, PR auto-merges to master
          3. ðŸ·ï¸ Release tag \`v$NEW_VERSION\` is created automatically
          4. ðŸ“¦ Release workflow builds binaries for all platforms
          5. ðŸŽ‰ GitHub Release is published with all artifacts
          
          **Timeline**: Full release process takes ~15-20 minutes
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << EOF
          âš ï¸  **Auto-merge NOT enabled** - RELEASE_PAT secret not configured
          
          ### What happens next?
          1. â³ CI checks run on the version bump PR
          2. ðŸ‘¤ **Manual action required**: Merge the version bump PR
          3. ðŸ·ï¸ After manual merge, run the tag workflow manually
          
          **Action needed**: Review and merge [$PR_URL]($PR_URL)
          
          ðŸ’¡ **Tip**: Configure RELEASE_PAT secret for fully automated releases.
          See [RELEASE_PAT_SETUP.md](docs/RELEASE_PAT_SETUP.md) for instructions.
          EOF
          fi
          
          cat >> $GITHUB_STEP_SUMMARY << EOF
          
          ### ðŸ”— Links
          - [Version Bump PR]($PR_URL)
          - [All Releases](https://github.com/${{ github.repository }}/releases)
          - [Actions](https://github.com/${{ github.repository }}/actions)
          EOF
